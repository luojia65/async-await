<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Run Await With Me</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/gruvbox-dark.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <!-- Introductions -->
            <section>
                <section>
                    <h1>Run Await With Me</h1>
                    Asynchronous Programming at RustConf 2018
                </section>
                <section>
                    Before we get started
                    <pre><code>
$ rustup update nightly
$ rustup override set nightly
                    </code></pre>
                </section>
                <section>
                    <section>
                        Introduction
                    </section>
                    <img src="assets/mgattozzi.jpg" style="float: right; width: 40%">
                    <ul style="width: 50%;">
                        <li>Michael Gattozzi</li>
                        <li>3+ Years of Rust</li>
                        <li>wasm-wg member</li>
                        <li>Maker of groan inducing puns</li>
                        <li>Anime nerd</li>
                        <li>Handle for everything: mgattozzi</li>
                        <li>@ me so I can get free dopamine</li>
                    </ul>
                </section>
                <section>
                    <img src="assets/michaelno1.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno2.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno3.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno4.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno5.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno6.png"></img>
                </section>
                <section>
                    <section>
                        Introduction
                    </section>
                    <img src="assets/cramertj.jpg" style="float: right; width: 40%">
                    <ul style="width: 50%;">
                      <li>Taylor Cramer</li>
                      <li>@cramertj on everything</li>
                      <li>Oxidizing since early 2016</li>
                      <li>Lang Design and Compiler Team Member</li>
                      <li>WG Net Async Lead</li>
                    </ul>
                </section>
                <section>
                    A few quick rules
                </section>
                <section>
                    Ask about missed references during breaks,<br>
                    and don't hate on my puns :D
                    <img src="assets/puns.png"></img>
                </section>
                <section>
                    It's okay to not know things
                    <img src="assets/motivation.png"></img>
                </section>
                <section>
                    Questions are good and encouraged!
                    <img src="assets/encourageyou.jpg"></img>
                </section>
                <section>
                    Have fun! We're learning exciting new things together!
                    <img src="assets/learning.gif"></img>
                </section>
            </section>

            <!-- History tiiiiiiime -->
            <section>
                <section>
                    The past and present of Futures<br>
                    <img src="assets/history.gif"></img>
                </section>
                <section>
                    Rust used to have lightweight userspace threads,<br>
                    often called M:N threads or "green threads."
                    <!-- mention similarities to goroutines -->
                </section>
                <section>
                    <section>
                        libgreen was introduced back in 2013!
                    </section>
                    <img src="assets/libgreen_add.png"></img>
                </section>
                <section>
                    Stack composed of runtime linked list of stacks:
                    <ul>
                        <li>Caused "stack thrashing"</li>
                        <li>FFI expects large stacks</li>
                    </ul>
                </section>
                <section>
                    <section>
                        libgreen was removed in 2014!
                    </section>
                    <img src="assets/libgreen_remove.png"></img>
                    <ul>
                        <li>No more runtime system</li>
                        <li>No more garbage collection</li>
                    </ul>
                </section>
                <section>
                    Is ergonomic async code possible in Rust?
                    <img src="assets/aliens.png"></img>
                </section>
                <section>
                    Spoiler Alert: Yes
                </section>
            </section>

            <!-- What's a Future -->
            <section>
                <section>
                    Back to the Future<br>
                    <img src="assets/backtothefuture.gif"></img>
                </section>
                <section>
                    So what's a Future?<br>
                    <img src="assets/ehhhh.PNG"></img>
                </section>
                <section>
                    Future = asynchronous computation<br><br>
                    <ul>
                        <li>Network IO</li>
                        <li>Message from another thread or computer</li>
                        <li>Chained operations</li>
                    </ul>
                </section>
                <section>
                    In other languages:<br><br>
                    <ul>
                        <li>Future is a concrete type</li>
                        <li>Actively driven to completion by runtime</li>
                        <li>Methods create callbacks spawned onto an executor</li>
                        <li>Allocation heavy (one per callback/map/and_then)</li>
                    </ul>
                </section>
                <section>
                    In Rust:<br><br>
                    <ul>
                        <li>Future is a trait</li>
                        <li>Does nothing unless passed to an executor and run</li>
                        <li>Methods create wrapper types which run their children</li>
                        <li>One allocation per top-level task</li>
                    </ul>
                </section>
                <section>
                    How are Rust futures run?<br><br>
                    <ul>
                        <li>Future spawned onto executor</li>
                        <li>Executor polls a Future</li>
                        <li>Future says "I'm not ready yet!"</li>
                        <li>Executor goes to sleep until Future sends a wakeup</li>
                    </ul>
                </section>
            </section>

            <!-- Polling -->
            <section>
                <section>
                    Poll Me Maybe<br>
                    <img src="assets/ey.jpg"></img>
                </section>
                <section>
                    <section>
                        How Futures act if you don't poll them for values
                    </section>
                    <img src="assets/tomorrow.jpg"></img>
                </section>
                <section>
                    What is Poll?<br>
                    <img src="assets/well.gif"></img>
                </section>
                <section data-transition="none">
                    Simplified signature:
                    <pre><code>
enum Poll&lt;T&gt; {
    Ready(T),
    Pending
}

trait Future {
    type Output;
    fn poll(&amp;mut self, wake: fn())
        &rarr; Poll&lt;Self::Output&gt;;
}
                    </code></pre>
                </section>
                <section data-transition="none">
                    The real thing:
                    <pre><code>
enum Poll&lt;T&gt; {
    Ready(T),
    Pending
}

trait Future {
    type Output;
    fn poll(self: PinMut&lt;Self&gt;, cx: &amp;mut task::Context)
        &rarr; Poll&lt;Self::Output&gt;;
}
                    </code></pre>
                </section>
            </section>

            <!-- Context -->
            <section>
                <section>
                    <h1>Concrete example time!</h1>
                    <img src="assets/together.jpg"></img>
                </section>
                <section>
                    Let's make the simplest possible future, `ready`.
                    <pre><code>
fn ready(x: i32) &rarr; impl Future&lt;Output = i32&gt; {
    ...
}
                    </code></pre>
                    <ul>
                        <li class = "fragment fade-in">Takes `i32` as input</li>
                        <li class = "fragment fade-in">Returns an immediately-ready Future</li>
                    </ul>
                </section>
                <section>
                    <pre><code data-noescape data-trim>
struct Ready { value: i32 }

fn ready(value: i32) &rarr; Ready {
    Ready { value }
}
<span class="fragment fade-in">
impl Future for Ready {
    type Output = <span class="fragment fade-in">i32;</span>
    fn poll(self: PinMut<Self>, cx: &amp;mut task::Context)
        &rarr; Poll&lt;Self::Output&gt;
    {
        <span class="fragment fade-in">Poll::Ready(<span class="fragment fade-in">self.value</span>)</span>
    }
}
</span>
                    </code></pre>
                </section>
                <section>
                  Most futures aren't immediately ready.
                  <ul>
                      <li class="fragment fade-in">Return Poll::Pending</li>
                      <li class="fragment fade-in">Schedule to receive wakeup</li>
                      <li class="fragment fade-in">Store "Waker" type (callback fn)</li>
                  </ul>
                </section>
                <section>
                  The Task Context and the Waker Type
                  <pre><code data-trim>
struct Context { ... }
impl Context {
    /// Returns the waker for the current task
    fn waker(&amp;self) &rarr; &amp;Waker { ... }
}

struct Waker { ... }
impl Waker {
    /// Wakes up the task associated with this `Waker`.
    fn wake(&amp;self) { ... }
}
                  </code></pre>
                </section>
                <section>
                    Let's make a Future that needs to be awoken!<br>
                    <span class="fragment fade-in">Once.</span><br>
                    <span class="fragment fade-in">Immediately.<pre><code data-trim>
struct AlmostReady { ready: bool, value: i32 }

fn almost_ready(value: i32) &rarr; AlmostReady {
    AlmostReady { ready: false, value }
}
                    </code></pre></span>
                </section>
                <section>
                <pre><code data-noescape data-trim>
struct AlmostReady { ready: bool, value: i32 }
impl Future for AlmostReady {
    type Output = i32;
    fn poll(mut self: PinMut&lt;Self&gt;, cx: &amp;mut task::Context)
        &rarr; Poll&lt;Self::Output&gt;
    {
        <span class="fragment fade-in">if self.ready {
            Poll::Ready(self.value)
        } else {
            self.ready = true;
            cx.waker().wake();
            Poll::Pending
        }</span>
    }
}               </code></pre>
                </section>
                <section>
                    Okay now it's your turn to implement a Future!
                </section>
                <section>
                    Don't worry you already have most of what you need!
                </section>
                <section>
                    Build a Future
                    <ul>
                        <li>Create a future that will resolve after 2 seconds</li>
                        <li>Don't block the event loop-- no sleeping on the main thread</li>
                        <li>To get started, <pre><code data-noescape data-trim>
$ git clone git@github.com:mgattozzi/async-await-class.git
$ cd async-await-class
$ vim src/timer.rs # or another editor of your choice
$ cargo run --bin timer # to check your solution
                        </code></pre></li>
                        <li>Replace the FIXMEs with proper solutions!</li>
                        <li>When done, you'll see the message "Completed future after 2s" </li>
                        <li>Ask lots of questions! The more you ask, the more we all learn!</li>
                    </ul>
                </section>
            </section>

            <section>
                Break Time y'all have worked hard!
            </section>

            <!-- TinyExecutor -->
            <section>
                <section>
                    Roll your own event Loop!
                </section>
                <section>
                    TinyExecutor<br>
                    <img src="assets/exeggutor.png">
                </section>
                <section>
                    Don't worry it won't be like this<br>
                    <img src="assets/drawtheowl.jpg">
                </section>
                <section>
                    Open up the code!
                    <pre><code data-trim>
$ emacs src/executor.rs # or something ;)
                    </code></pre>
                </section>
                <section>
                    The primary building blocks here are:<br><br>
                    <ul>
                      <li>The Executor and Spawner types (channel ends)</li>
                      <li>The Task type (a pair of Mutex<Future> and Spawner)</li>
                    </ul>
                </section>
                <section>
                    Let's a look at the implementation of the `Spawn` trait together.
                </section>
                <section>
                    Now, fill out the two FIXMEs to get a working executor!
                    The `impl Wake for Task` one is easier, so we recommend
                    starting with that. As always, please ask lots of questions
                    and we'll do our best to assist. :)
                </section>
            </section>

            <section>
                Alright time for another quick break
            </section>

            <!-- async/await!() -->
            <section>

                <section>
                    async/await!()
                </section>

                <section>
                    We've been talking a lot about how to execute async functions but what even is one?
                    Where does await come into this whole thing?
                </section>

                <section>
                    We spent some time manually implementing a Future, but that was tedious. We had to
                    keep track of state, how to make sure it was ready, etc. That's too much work!
                </section>

                <section>
                    This is where the async keyword comes in it automatically turns functions, closures, and
                    expressions asynchronous for us!
                </section>

                <section>
                    <pre><code>fn cinderella() {
    println!("I wish I could go to the event loop ball");
}</code></pre>
                </section>

                <section>
                    <pre><code>async fn cinderella() {
    println!("I can go to the event loop ball now!");
}</code></pre>
                </section>

                <section>
                    rustc transforming a function into an async function<br>
                    <video data-autoplay src="assets/asynctransform.mp4"></video>
                </section>

                <section>
                    Neat huh? Okay so if that's async what's await!(). Why is it even a macro?
                </section>

                <section>
                    await lets you use Futures in Futures and get values from Futures in your Futures
                </section>

                <section>
                    <img src="assets/yodawg.jpg"></img>
                </section>

                <section>
                    Here's a simple example with await!()
                    <pre><code>async fn second() {
    println!("Second");
}
async fn third() {
    println!("Third");
}
async fn first() {
    let third = third();
    let second = second();
    println!("First");
    await!(second);
    await!(third);
}</code></pre>
                </section>

                <section>
                    So now that we know it will execute a Future inside our function why is it a macro?
                </section>

                <section>
                    We still want to play around with it and nail down a good design. Choosing the interface
                    without experimentation locks us in.
                </section>

                <section>
                    It's like when we had try!() then eventually had ?<br>
                    await!() will become just await eventually
                </section>

                <section>
                    Here's what it might look like
                    <pre><code>async fn second() {
    println!("Second");
}
async fn third() {
    println!("Third");
}
async fn first() {
    let third = third();
    let second = second();
    println!("First");
    await second;
    await third;
}</code></pre>
                </section>

                <section>
                    It's a macro though. So what does that even look like?
                </section>

                <section>
                    Currently it looks like this
                    <pre style="font-size: 50%;"><code>macro_rules! await {
    ($e:expr) => { {
        let mut pinned = $e;
        loop {
            if let $crate::task::Poll::Ready(x) =
                $crate::future::poll_in_task_cx(unsafe {
                    $crate::mem::PinMut::new_unchecked(&amp;mut pinned)
                })
            {
                break x;
            }
            yield
        }
    } }
}</code></pre>
                </section>
                <section>
                    async/await are not hard! What's hard is getting Futures to run,
                    but you've already done the hard work!
                </section>

            </section>

            <!-- Closing/Future Developments -->
            <section>
                <section>
                    We're a couple hours into the Future
                </section>
                <section>
                    If I polled you all on how confident you are with Futures
                </section>
                <section>
                    I think I would get a response of Poll::Ready(Knowledge)
                </section>
                <section>
                    Some cool things to look out for down the line
                </section>
                <section>
                    Futures-rs is an abstraction over Futures<br>
                    <img src="assets/futuresrs.png"><br>
                    Nice iterator like adaptors for Futures
                </section>
                <section>
                    Tokio is a solid more efficient event loop for you to use!<br>
                    <img src="assets/tokio.png"><br>
                    No need for you to make an event loop
                </section>
                <section>
                    What does this all mean?<br>
                    <img src="assets/itjustworks.jpg"></img>
                </section>
                <section>
                    You'll have an understanding of what your code is doing under the hood
                </section>
                <section>
                    You'll appreciate those nice libraries and abstractions
                </section>
                <section>
                    They won't be black magic now though
                </section>
                <section>
                    Unfortunately this is the end of the class
                </section>
                <section>
                    It's time to go<br>
                    <img src="assets/dontwannago.gif"></img>
                </section>
                <section>
                    Big thanks to cramertj and aturon for helping with this class through planning, code, and more
                </section>
                <section>
                    Thank you all for coming!<br>
                    <img src="assets/end.gif"></img>
                </section>
                <section>
                </section>
            </section>

        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'plugin/markdown/marked.js' },
                { src: 'plugin/markdown/markdown.js' },
                { src: 'plugin/notes/notes.js', async: true },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
            ]
        });
    </script>
</body>

</html>
