<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Run Await With Me</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/gruvbox-dark.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <!-- Introductions -->
            <section>
                <section>
                    Run Await With Me
                    <br>Asynchronous Programming at RustConf 2018
                </section>
                <section>
                    Before we get started
                    <pre><code>
$ rustup update nightly
$ rustup override set nightly
                    </code></pre>
                </section>
                <section>
                    <section>
                        Introduction
                    </section>
                    <img src="assets/mgattozzi.jpg" style="float: right; width: 40%">
                    <ul style="width: 50%;">
                        <li>Michael Gattozzi</li>
                        <li>3+ Years of Rust</li>
                        <li>wasm-wg member</li>
                        <li>Maker of groan inducing puns</li>
                        <li>Anime nerd</li>
                        <li>Handle for everything: mgattozzi</li>
                        <li>@ me so I can get free dopamine</li>
                    </ul>
                </section>
                <section>
                    <img src="assets/michaelno1.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno2.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno3.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno4.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno5.png"></img>
                </section>
                <section>
                    <img src="assets/michaelno6.png"></img>
                </section>
                <section>
                    <section>
                        Introduction
                    </section>
                    <img src="assets/cramertj.jpg" style="float: right; width: 40%">
                    <ul style="width: 50%;">
                      <li>Taylor Cramer</li>
                      <li>@cramertj on everything</li>
                      <li>Oxidizing since early 2016</li>
                      <li>Lang Design and Compiler Team Member</li>
                      <li>WG Net Async Lead</li>
                    </ul>
                </section>
                <section>
                    A few quick rules
                </section>
                <section>
                    Ask about missed references during breaks,<br>
                    and don't hate on my puns :D
                    <img src="assets/puns.png"></img>
                </section>
                <section>
                    It's okay to not know things
                    <img src="assets/motivation.png"></img>
                </section>
                <section>
                    Questions are good and encouraged!
                    <img src="assets/encourageyou.jpg"></img>
                </section>
                <section>
                    Have fun! We're learning exciting new things together!
                    <img src="assets/havefun.gif"></img>
                </section>
            </section>

            <!-- History tiiiiiiime -->
            <section>
                <section>
                    The past and present of Future<br>
                    <img src="assets/history.gif"></img>
                </section>
                <section>
                    Rust used to have lightweight userspace threads,<br>
                    often called M:N threads or "green threads."
                    <!-- mention similarities to goroutines -->
                </section>
                <section>
                    <section>
                        libgreen was introduced back in 2013!
                    </section>
                    <img src="assets/libgreen_add.png"></img>
                </section>
                <section>
                    Stack composed of runtime linked list of stacks:
                    <ul>
                        <li>Caused "stack thrashing"</li>
                        <li>FFI expects large stacks</li>
                    </ul>
                </section>
                <section>
                    <section>
                        libgreen was removed in 2014!
                    </section>
                    <img src="assets/libgreen_remove.png"></img>
                    <ul>
                        <li>No more runtime system</li>
                        <li>No more garbage collection</li>
                    </ul>
                </section>
                <section>
                    Is ergonomic async code possible in Rust?
                    <img src="assets/aliens.png"></img>
                </section>
                <section>
                    Spoiler Alert: Yes
                </section>
            </section>

            <!-- What's a Future -->
            <section>
                <section>
                    Back to the Future<br>
                    <img src="assets/backtothefuture.gif"></img>
                </section>
                <section>
                    So what's a Future?<br>
                    <img src="assets/ehhhh.PNG"></img>
                </section>
                <section>
                    Future = asynchronous computation<br><br>
                    <ul>
                        <li>Network IO</li>
                        <li>Message from another thread or computer</li>
                        <li>Chained operations</li>
                    </ul>
                </section>
                <section>
                    In other languages:<br><br>
                    <ul>
                        <li>Future is a concrete type</li>
                        <li>Actively driven to completion by runtime</li>
                        <li>Methods create callbacks spawned onto an executor</li>
                        <li>Allocation heavy (one per callback/map/and_then)</li>
                    </ul>
                </section>
                <section>
                    In Rust:<br><br>
                    <ul>
                        <li>Future is a trait</li>
                        <li>Does nothing unless passed to an executor and run</li>
                        <li>Methods create wrapper types which run their children</li>
                        <li>One allocation per top-level task</li>
                    </ul>
                </section>
                <section>
                    How are Rust futures run?<br><br>
                    <ul>
                        <li>Future spawned onto executor</li>
                        <li>Executor polls a Future</li>
                        <li>Future says "I'm not ready yet!"</li>
                        <li>Executor goes to sleep until Future sends a wakeup</li>
                </section>
            </section>

            <!-- Polling -->
            <section>
                <section>
                    Poll Me Maybe<br>
                    <img src="assets/ey.jpg"></img>
                </section>
                <section>
                    <section>
                        How Futures act if you don't poll them for values
                    </section>
                    <img src="assets/tomorrow.jpg"></img>
                </section>
                <section>
                    What is Poll?<br>
                    <img src="assets/well.gif"></img>
                </section>
                <section>
                    Simplified signature:
                    <pre><code>
enum Poll&lt;T&gt; {
    Ready(T),
    Pending
}

trait Future {
    type Output;
    fn poll(&amp;mut self, wake: fn()) &rarr; Poll&lt;Self::Output&gt;;
}
                    </code></pre>
                </section>
            </section>

            <!-- Context -->
            <section>
                <section>
                    The Legend of Context: The Future Waker<br>
                    <img src="assets/windwaker.jpg"></img>
                </section>
                <section>
                    Let's do a concrete example together!<br>
                    <img src="assets/together.jpg"></img>
                </section>
                <section>
                    <pre><code>
 $ cargo new my_executor --bin
 $ cd my_executor
 $ vim Cargo.toml # emacs is fine, too, I guess
                    </code></pre>
                </section>
                <section>
                    Add the missing lines to make it look like this:
                    <pre><code>cargo-features=["edition"] #------ add this one

[package]
name = "my_executor"
version = "0.1.0"
authors = ["Michael Gattozzi &lt;mgattozzi@gmail.com&gt;"]
edition = "2018" # ------ and this one

# and these ones-- this will be our first binary target,
# but we'll add others later.
[[bin]]
path = "src/waker.rs"
name = "waker"
                  </code></pre>
                </section>
                <section>
                    Cool now we have it set so we have 2018 edition enabled automatically!
                </section>
                <section>
                    We also now have this example set so all we need to do to run it is
                    <pre><code>cargo run --bin waker</code></pre>
                </section>
                <section>
                    Okay create a file src/waker.rs and open it up
                </section>
                <section>
                    Add this to the top to enable the nightly features we need
                    <pre><code>#![feature(arbitrary_self_types, futures_api, pin)]</code></pre>
                </section>
                <section>
                    What's Rust code without some imports? Here's what we'll need
                    <pre><code>use std::sync::mpsc::{sync_channel, SyncSender};
use std::future::{Future, FutureObj};
use std::mem::PinMut;
use std::sync::{Arc, Mutex};
use std::task::{
    Context,
    Executor,
    local_waker_from_nonlocal,
    Poll,
    SpawnObjError,
    Wake,
};</code></pre>
                </section>
                <section>
                    Alright so we need some kind of executor that can spawn Futures in order to create a Context
                    type. We won't be using it in this example so we'll create a stub to satsify our instatiable
                    overlord rustc.
                </section>
                <section>
                    <pre><code>struct Exec;
impl Executor for Exec {
    fn spawn_obj(&amp;mut self, _obj: FutureObj&lt;'static, ()&gt;)
        -> Result&lt;(), SpawnObjError&gt;
    {
        Ok(())
    }
}</code></pre>
                </section>
                <!-- Future Trait and Waker -->
                <section>
                    Okay, so we're now gonna implement the Future trait ourselves
                </section>
                <section>
                    While this will let you see how this works under the hood you normally
                    should just tag functions or things with async.
                </section>
                <section>
                    Why? rustc will handle when tasks need to be woken up when polled or if
                    it's ready. You won't need to think about all the logic involved with that.
                </section>
                <section>
                    Let's create a simple type like so:
                    <pre><code>struct MyFuture(bool);</code></pre>
                </section>
                <section>
                    The Future when polled will return Poll::Pending the first time and Poll::Ready(()) the
                    second time it's polled
                </section>
                <section>
                    <pre><code>impl Future for MyFuture {
    type Output = ();
    fn poll(mut self: PinMut&lt;Self&gt;, cx: &amp;mut Context)
        -> Poll&lt;Self::Output&gt;
    {
        if self.0 {
            return Poll::Ready(());
        }
        self.0 = true;
        cx.waker().wake();
        Poll::Pending
    }
}</code></pre>
                </section>
                <section>
                    Implementing the Waker trait
                </section>
                <section>
                    <img src="assets/pollpoll.png"></img>
                </section>
                <section>
                    <pre><code>struct Task {
    sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
    future: Mutex&lt;MyFuture&gt;
}
impl Wake for Task {
    fn wake(arc_self: &amp;Arc&lt;Self&gt;>) {
        let cloned = arc_self.clone();
        let _ = arc_self.sender.send(cloned);
    }
}</code></pre>
                </section>
                <section>
                    <pre><code>fn main() {
    let mut exec = Exec;
    let (tx, rx) = sync_channel(1000);
    let task = Arc::new(Task {
        future: Mutex::new(MyFuture(false)),
        sender: tx.clone()
    });
    let waker = local_waker_from_nonlocal(task.clone());
    let cx = &amp;mut Context::new(&amp;waker, &amp;mut exec);
    let _ = tx.send(task);</code></pre>
                </section>
                <section>
                    <pre><code>    while let Ok(task) = rx.recv() {
        let mut future = task.future.lock().unwrap();
        match PinMut::new(&amp;mut *future).poll(cx) {
            Poll::Pending =&gt; println!("Pending"),
            Poll::Ready(()) =&gt; {
                println!("Ready");
                break;
            },
        }
    }
}</code></pre>
                </section>
                <section>
                     Now execute it! You should see Pending printed out then Ready and it will cancel
                </section>
                <section>
                    Okay now it's your turn to implement a Future!
                </section>
                <section>
                    Don't worry you already have most of what you need!
                </section>
                <section>
                    <section>
                        Build a Future
                    </section>
                    <ul>
                        <li>
                            Your goal is to create a Future that can wait n seconds and will print out
                            when n seconds have passed.
                        </li>
                        <li>
                            You will need std::time::{Instant, Duration};
                        </li>
                        <li>
                            You will need a new type and implement Future for it
                        </li>
                        <li>
                            If the time alloted hasn't passed wake the Future. We don't want to block
                        </li>
                        <li>
                            Don't use thread::sleep to get a certain period of time to pass
                        </li>
                    </ul>
                </section>
            </section>

            <section>
                Break Time y'all have worked hard!
            </section>

            <!-- TinyExecutor -->
            <section>
                <section>
                    Roll your own Event Loop!
                </section>
                <section>
                    TinyExecutor<br>
                    <img src="assets/exeggutor.png">
                </section>
                <section>
                    Don't worry it won't be like this<br>
                    <img src="assets/drawtheowl.jpg">
                </section>
                <!-- Spawn Trait -->
                <section>
                    Before we get started on this we need to cover a few things like
                    setting up the file, the Executor trait, and then what types you
                    will have for the whole thing
                </section>
                <section>
                    Open up that Cargo.toml and change it to have this in it:
                    <pre><code>[[bin]]
path = "src/tiny.rs"
name = "tiny"</code></pre>
                </section>
                <section>
                    To run this code all you need to run now is:
                    <pre><code>cargo run --bin waker</code></pre>
                </section>
                <section>
                    Okay create a file src/tiny.rs and open it up
                </section>
                <section>
                    Add this to the top to enable the nightly features we need
                    <pre><code>#![feature(async_await, await_macro, futures_api, pin)]</code></pre>
                </section>
                <section>
                    Here's all the imports you'll need:
                    <pre><code>use std::future::{Future, FutureObj};
use std::mem::PinMut;
use std::sync::{Arc, Mutex};
use std::sync::mpsc::{
    sync_channel,
    SyncSender,
    SendError,
    Receiver
};</code></pre>
                </section>
                <section>
                    <pre><code>use std::task::{
    self,
    Executor,
    local_waker_from_nonlocal,
    Poll,
    SpawnErrorKind,
    SpawnObjError,
    Wake,
};</code></pre>
                </section>
                <section>
                    Alright now let's add two type definitions you'll need
                </section>
                <section>
                    <pre><code>struct Exec {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
    task_receiver: Receiver&lt;Arc&lt;Task&gt;&gt;,
}</code></pre>
                </section>
                <section>
                    <pre><code>struct Task {
    future: Mutex&lt;Option&lt;FutureObj&lt;'static, ()&gt;&gt;&gt;;,
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}</code></pre>
                </section>
                <section>
                    These are all the types you'll need and get for this exercise. Let's cover how to
                    implement Executor, what it's used for, and the definition for our event loop.
                </section>
                <section>
                    A little earlier we saw a stubbed out Executor. So what is it?
                </section>
                <section>
                    It's what spawns new Futures into your queue of Futures that need to be run
                </section>
                <section>
                    If a Waker puts Futures back in the queue then an Executor spawns them into it
                </section>
                <section>
                    So what does our implementation going to look like?
                </section>
                <section>
                    <pre><code>impl&lt;'a&gt; Executor for &amp;'a Exec {
    fn spawn_obj(&amp;mut self, future: FutureObj&lt;'static, ()&gt;)
        -> Result&lt;(), SpawnObjError&gt;
    {
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });</code></pre>
                </section>
                <section>
                    <pre><code>        self.task_sender
            .send(task)
            .map_err(|SendError(task)| {
                SpawnObjError {
                    kind: SpawnErrorKind::shutdown(),
                    future: task.future
                        .lock()
                        .unwrap()
                        .take()
                        .unwrap(),
                }
            })
    }
}</code></pre>
                </section>
                <section>
                    Now it's your turn to code<br>
                    <img src="assets/typing.gif">
                </section>
                <section>
                    <section>
                        Build the rest of TinyExec
                    </section>
                    <ul style="font-size: 80%;">
                        <li>
                            Implement Waker for Task
                        </li>
                        <li>
                            Make an impl Exec that contains the functions:
                            <pre><code>fn new() -> Self
fn run(&amp;self)</code></pre>
                        </li>
                        <li>
                            run should be a loop that takes a task off of task_reciever
                        </li>
                        <li>
                            Once it has the task check that it has a future that can be executed
                        </li>
                        <li>
                            If it does create a LocalWaker and Context object with a reference to the executor
                        </li>
                        <li>
                            PinMut the future and poll it and if it's still Pending make sure that the Task has the
                            Future back inside it
                        </li>
                        <li>
                            Create a main function, create a new executor, spawn a new future into it and execute it
                        </li>
                        <li>
                            <pre><code>FutureObj::new(Box::new(async { println!("I'm a spawned future")})</code></pre>
                        </li>
                    </ul>
                </section>
            </section>

            <section>
                Alright time for another quick break
            </section>

            <!-- async/await!() -->
            <section>

                <section>
                    async/await!()
                </section>

                <section>
                    We've been talking a lot about how to execute async functions but what even is one?
                    Where does await come into this whole thing?
                </section>

                <section>
                    We spent some time manually implementing a Future, but that was tedious. We had to
                    keep track of state, how to make sure it was ready, etc. That's too much work!
                </section>

                <section>
                    This is where the async keyword comes in it automatically turns functions, closures, and
                    expressions asynchronous for us!
                </section>

                <section>
                    <pre><code>fn cinderella() {
    println!("I wish I could go to the event loop ball");
}</code></pre>
                </section>

                <section>
                    <pre><code>async fn cinderella() {
    println!("I can go to the event loop ball now!");
}</code></pre>
                </section>

                <section>
                    rustc transforming a function into an async function<br>
                    <video data-autoplay src="assets/asynctransform.mp4"></video>
                </section>

                <section>
                    Neat huh? Okay so if that's async what's await!(). Why is it even a macro?
                </section>

                <section>
                    await lets you use Futures in Futures and get values from Futures in your Futures
                </section>

                <section>
                    <img src="assets/yodawg.jpg"></img>
                </section>

                <section>
                    Here's a simple example with await!()
                    <pre><code>async fn second() {
    println!("Second");
}
async fn third() {
    println!("Third");
}
async fn first() {
    let third = third();
    let second = second();
    println!("First");
    await!(second);
    await!(third);
}</code></pre>
                </section>

                <section>
                    So now that we know it will execute a Future inside our function why is it a macro?
                </section>

                <section>
                    We still want to play around with it and nail down a good design. Choosing the interface
                    without experimentation locks us in.
                </section>

                <section>
                    It's like when we had try!() then eventually had ?<br>
                    await!() will become just await eventually
                </section>

                <section>
                    Here's what it might look like
                    <pre><code>async fn second() {
    println!("Second");
}
async fn third() {
    println!("Third");
}
async fn first() {
    let third = third();
    let second = second();
    println!("First");
    await second;
    await third;
}</code></pre>
                </section>

                <section>
                    It's a macro though. So what does that even look like?
                </section>

                <section>
                    Currently it looks like this
                    <pre style="font-size: 50%;"><code>macro_rules! await {
    ($e:expr) => { {
        let mut pinned = $e;
        loop {
            if let $crate::task::Poll::Ready(x) =
                $crate::future::poll_in_task_cx(unsafe {
                    $crate::mem::PinMut::new_unchecked(&amp;mut pinned)
                })
            {
                break x;
            }
            yield
        }
    } }
}</code></pre>
                </section>
                <section>
                    async/await are not hard! What's hard is getting Futures to run,
                    but you've already done the hard work!
                </section>

            </section>

            <!-- Closing/Future Developments -->
            <section>
                <section>
                    We're a couple hours into the Future
                </section>
                <section>
                    If I polled you all on how confident you are with Futures
                </section>
                <section>
                    I think I would get a response of Poll::Ready(Knowledge)
                </section>
                <section>
                    Some cool things to look out for down the line
                </section>
                <section>
                    Futures-rs is an abstraction over Futures<br>
                    <img src="assets/futuresrs.png"><br>
                    Nice iterator like adaptors for Futures
                </section>
                <section>
                    Tokio is a solid more efficient event loop for you to use!<br>
                    <img src="assets/tokio.png"><br>
                    No need for you to make an event loop
                </section>
                <section>
                    What does this all mean?<br>
                    <img src="assets/itjustworks.jpg"></img>
                </section>
                <section>
                    You'll have an understanding of what your code is doing under the hood
                </section>
                <section>
                    You'll appreciate those nice libraries and abstractions
                </section>
                <section>
                    They won't be black magic now though
                </section>
                <section>
                    Unfortunately this is the end of the class
                </section>
                <section>
                    It's time to go<br>
                    <img src="assets/dontwannago.gif"></img>
                </section>
                <section>
                    Big thanks to cramertj and aturon for helping with this class through planning, code, and more
                </section>
                <section>
                    Thank you all for coming!<br>
                    <img src="assets/end.gif"></img>
                </section>
                <section>
                </section>
            </section>

        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'plugin/markdown/marked.js' },
                { src: 'plugin/markdown/markdown.js' },
                { src: 'plugin/notes/notes.js', async: true },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
            ]
        });
    </script>
</body>

</html>
